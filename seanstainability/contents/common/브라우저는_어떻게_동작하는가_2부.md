---
date: '2021-08-13'
title: '브라우저는 어떻게 동작하는가 - 2부'
categories: ['브라우저']
summary: '브라우저 동작 원리에 대한 흐름을 알아본다.'
thumbnail: 'resources/browser.png'
---

# 브라우저는 어떻게 동작하는가 - 2부

## 렌더러 프로세스가 HTML 문서를 받았을 때 어떤 절차를 거쳐 화면을 구성하는가.

## 렌더러 프로세스

- 메인 스레드
- 워커 스레드
- 컴포지터 스레드
- 래스터 스레드

## 렌더링 파이프라인

**DOM : 파싱 -> CSSOM : 스타일 계산 -> Render Tree : 레이아웃 -> Paint Tree : 페인트 -> Compositor Frame: 합성**

### 파싱

- 문자열 HTML을 해석하여 DOM 객체 트리로 변환한다.
- DOM을 구축하는 동안 프리로드(Preload) 스캐너가 동시에 실행되어 <img>, <link>같은 태그가 있으면 브라우저 프로세스의 네트워크 스레드에 요청을 보낸다.
- HTML 파서는 <script> 태그를 만나면 HTML 문서의 파싱을 일시 중지한 다음 자바스크립트 코드를 로딩하고 파싱해 실행한다.(자바스크립트가 문서의 모양을 변경할 수 있기 때문이다.)
- <script> 태그에 async 속성이나 defer 속성을 추가하면 브라우저가 자바스크립트 코드를 비동기적으로 로딩하고 실행하면서 HTML 파싱을 막지 않는다.

### 스타일 계산

- 메인 스레드는 CSS를 파싱하고 각 DOM 노드에 해당되는 계산된 스타일(computed style)을 확정한다.(개발자 도구의 computed 패널에서 확인이 가능하다.)

### 레이아웃

- 메인 스레드는 DOM과 CSSOM을 훑어가며 렌더 트리를 만든다.
- 렌더 트리는 위치, 크기, 모양 같은 정보를 가지고 있고, 해당 페이지에 보이는 요소에 관련된 정보만 가지고 있다.
- 렌더 트리를 순회하면서 속성 트리를 별도로 만든다.(노드마다 속성 정보를 가지고 있는 것이 아니라 속성 트리에서 속성은 별도로 관리하고, 각 노드는 속성 트리의 노드를 참조한다.)

### 페인트

- 메인 스레드는 페인트 기록(paint record)을 생성하기 위해 렌더 트리를 순회하면서 **어떤 순서로 그려야 할지**를 판단하여 기록한다.

### 합성

- 웹 페이지의 각 부분을 레이어로 분리해 별도로 래스터화(rasterizing, 정보를 화면의 픽셀로 변환하는 작업)한다.
  - 메인 스레드가 어떤 요소가 어떤 레이어에 있어야 하는지 확인하기 위해 렌더 트리를 순회하면서 레이어 트리를 만든다.(개발자 도구의 Performance 패널에서 Update Layer Tree라고 되어 있다.)
  - 컴포지터 스레드는 레이어를 타일(tile) 형태로 나눠 각 타일을 래스터 스레드로 보낸다.
  - 래스터 스레드는 각 타일을 래스터화해 GPU 메모리에 저장한다.
- 컴포지터 스레드에서 타일을 움직여 웹페이지로 합성한다.(합성 프레임, 스크롤 되었을 때 레이어는 이미 래스터화되어 있으므로 새 프레임을 합성하기만 하면 된다. 애니메이션도 동일)

## 컴포지터가 사용자 입력을 받았을 때

- 사용자 제스처가 발생하면 브라우저 프로세스는 이벤트 유형과 이벤트가 발생한 좌표를 렌더러 프로세스로 보낸다.
- 렌더러 프로세스는 이벤트 대상을 찾고 해당 대상과 연결된 이벤트 리스너를 실행해 이벤트를 적절하게 처리한다.

### 고속 스크롤 불가 영역

- 자바스크립트 실행은 메인 스레드의 작업이므로, 웹 페이지가 합성될 때 컴포지터 스레드는 이벤트 핸들러가 연결된 영역을 '고속 스크롤 불가 영역'이라고 표시한다.
- 입력 이벤트가 고속 스크롤 불가 영역 밖에서 발생했다면 컴포지터 스레드는 메인 스레드를 기다리지 않고 새 프레임을 합성한다.

- 하나의 이벤트 핸들러를 최상위 요소에 연결하여 이벤트를 위임할 경우 웹 페이지의 모든 영역이 고속 스크롤 불가 영역으로 표시된다.
- 이때 컴포지터 스레드는 입력 이벤트가 들어올 때마다 메인 스레드와 통신해야 하고 메인 스레드가 일을 끝내기를 기다려야 한다.(부드러운 스크롤링이 어렵다.)
- 여전히 메인 스레드에서 이벤트를 받지만 컴포지터가 메인 스레드의 처리를 기다리지 않고 새 프레임을 만들 수 있도록 이벤트 핸들러에 `passive: true` 옵션을 줄 수 있다.

### 메인 스레드로 이벤트를 전송하는 것을 최소화하기

- 메인 스레드 호출이 과도해지는 것을 막기 위해 브라우저는 연속적인 이벤트(mousewheel , mousemove 등)를 합쳐서 바로 다음번 requestAnimationFrame() 메서드 실행 직전까지 전송(dispatch)하지 않고 기다린다.
- keydown, keyup과 같은 비연속적인(discrete) 이벤트는 즉시 전달된다.

## 참조

- [최신 브라우저의 내부 살펴보기 3 - 렌더러 프로세스의 내부 동작](https://d2.naver.com/helloworld/5237120)
- [최신 브라우저의 내부 살펴보기 4 - 컴포지터가 사용자 입력을 받았을 때](https://d2.naver.com/helloworld/6204533)
