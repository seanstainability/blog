{"componentChunkName":"component---src-templates-post-template-tsx","path":"/브라우저는_어떻게_동작하는가_2부/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>브라우저는 어떻게 동작하는가 - 2부</h1>\n<h2>렌더러 프로세스가 HTML 문서를 받았을 때 어떤 절차를 거쳐 화면을 구성하는가.</h2>\n<h2>렌더러 프로세스</h2>\n<ul>\n<li>메인 스레드</li>\n<li>워커 스레드</li>\n<li>컴포지터 스레드</li>\n<li>래스터 스레드</li>\n</ul>\n<h2>렌더링 파이프라인(Critical rendering path)</h2>\n<p><strong>request &#x26; response → loading → scripting → rendering → layout → painting</strong></p>\n<ul>\n<li>Construction : HTML 파일을 브라우저가 이해할 수 있도록 DOM, CSSOM, 렌더트리를 구축하는 파트\n<ul>\n<li>DOM 요소, CSS 규칙을 최대한 간단하게 만들어 <strong>트리를 작게 만드는 것</strong>이 성능 개선에 중요하다.</li>\n</ul>\n</li>\n<li>Operation : 렌더트리를 가지고 어느 위치에 배치할지를 계산하고, 실제로 화면에 그려주는 파트\n<ul>\n<li>layout : 레이아웃(위치, 크기, 모양 등)을 계산한다.</li>\n<li>paint : layout의 결과에 따라 부분 부분으로 나누어 이미지를 준비한다. (브라우저마다 성능 개선을 위해 레이어 단위로 이미지를 준비해 두는 것, 변경이 발생할 경우 해당 레이어만 업데이트하면 되기 때문)\n→ CSS will-change 속성은 브라우저에게 해당 요소의 속성값이 변경될지도 모른다고 미리 알려 별도의 레이어로 이미지를 준비하도록 한다. (성능을 고려해서 남용하지 말 것)\n→ 레이어는 <code class=\"language-text\">개발자 도구 - More tools - Layers</code>에서 확인이 가능하다.</li>\n<li>composition : 레이어를 차곡차곡 화면 위에 표기한다.</li>\n<li>성능 개선에 있어 최선은 composition, 차선은 paint, 최악은 layout이 다시 발생하도록 하는 것이다.</li>\n<li>내가 쓰고 있는 CSS 속성 값이 성능에 어떤 영향을 주는지 확인하기 위한 <a href=\"https://csstriggers.com/\" target=\"_blank\" rel=\"nofollow\">사이트</a></li>\n<li>성능 개선 증거를 남기기 위한 방법으로는 개발자 도구 Performance 탭의 record 기능이다.\n<ul>\n<li>Layout shift가 얼마나 발생하는지 확인한다.</li>\n<li>개발툴 팔레트(cmd + shift + p)를 열어 ‘show layout shift regions’을 선택하면 Layout이 언제 발생하는지를 화면에서 시각적으로도 확인 가능하다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>DOM : 파싱 -> CSSOM : 스타일 계산 -> Render Tree : 레이아웃 -> Paint Tree : 페인트 -> Compositor Frame: 합성</strong></p>\n<h3>파싱</h3>\n<ul>\n<li>메인 스레드는 문자열 HTML 태그를 해석하여 DOM 객체 트리로 변환한다. <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API\" target=\"_blank\" rel=\"nofollow\">DOM APIs</a>\n<ul>\n<li>Node는 EventTarget 객체를 상속한다. 즉, 모든 노드는 이벤트가 발생할 수 있다.</li>\n<li>Document, Element, Text 등 Node를 상속하는 것들의 종류는 다양하다.</li>\n</ul>\n</li>\n<li>DOM을 구축하는 동안 프리로드(Preload) 스캐너가 동시에 실행되어 <code class=\"language-text\">&lt;img></code>, <code class=\"language-text\">&lt;link></code>같은 태그가 있으면 브라우저 프로세스의 네트워크 스레드에 요청을 보낸다.</li>\n<li>HTML 파서는 <code class=\"language-text\">&lt;script></code> 태그를 만나면 HTML 문서의 파싱을 일시 중지한 다음 자바스크립트 코드를 로딩하고 파싱해 실행한다.(일시 중지하는 이유는 자바스크립트가 문서의 모양을 변경할 수 있기 때문이다.)</li>\n<li><code class=\"language-text\">&lt;script></code> 태그에 async 속성이나 defer 속성을 추가하면 브라우저가 자바스크립트 코드를 비동기적으로 로딩하고 실행하면서 HTML 파싱을 막지 않는다.</li>\n</ul>\n<h3>스타일 계산</h3>\n<ul>\n<li>메인 스레드는 CSS를 파싱하고 각 DOM 노드에 해당되는 계산된 스타일(computed style)을 확정한다.(개발자 도구의 computed 패널에서 확인이 가능하다.)</li>\n<li>우리가 정의한 스타일, 브라우저에서 기본적으로 설정된 스타일 등을 cascading rules에 따라 모두 계산하여 CSSOM을 만든다.</li>\n</ul>\n<h3>레이아웃</h3>\n<ul>\n<li>메인 스레드는 DOM과 CSSOM을 훑어가며 렌더 트리를 만든다.</li>\n<li>렌더 트리는 위치, 크기, 모양 같은 정보를 가지고 있고, 해당 페이지에 보이는 요소에 관련된 정보만 가지고 있다.\n→ display가 none인 경우 Render Tree에는 포함되지 않는다.</li>\n<li>렌더 트리를 순회하면서 속성 트리를 별도로 만든다.(노드마다 속성 정보를 가지고 있는 것이 아니라 속성 트리에서 속성은 별도로 관리하고, 각 노드는 속성 트리의 노드를 참조한다.)</li>\n</ul>\n<h3>페인트</h3>\n<ul>\n<li>메인 스레드는 페인트 기록(paint record)을 생성하기 위해 렌더 트리를 순회하면서 <strong>어떤 순서로 그려야 할지</strong>를 판단하여 기록한다.</li>\n</ul>\n<h3>합성</h3>\n<ul>\n<li>\n<p>웹 페이지의 각 부분을 레이어로 분리해 별도로 래스터화(rasterizing, 정보를 화면의 픽셀로 변환하는 작업)하고, 컴포지터 스레드에서 웹페이지로 합성한다.</p>\n<ul>\n<li>메인 스레드가 어떤 요소가 어떤 레이어에 있어야 하는지 확인하기 위해 렌더 트리를 순회하면서 레이어 트리를 만들고, 페인트 순서를 결정한다.(개발자 도구의 Performance 패널에서 Update Layer Tree라고 되어 있다.)</li>\n<li>메인 스레드가 해당 정보를 컴포지터 스레드에게 넘긴다.</li>\n<li>컴포지터 스레드는 레이어를 타일(tile) 형태로 나눠 각 타일을 래스터 스레드로 보낸다.</li>\n<li>래스터 스레드는 각 타일을 래스터화해 GPU 메모리에 저장한다.(타일 단위로 비트맵을 만들고 GPU로 보낸다.)</li>\n<li>타일이 래스터화되면 컴포지터 스레드는 합성 프레임을 생성하기 위해 타일의 정보를 모은다.(이 타일의 정보를 ‘드로 쿼드’라 부른다.)</li>\n<li>합성 프레임은 IPC를 통해 브라우저 프로세스로 전송되고, GPU를 통해 화면에 표시된다.</li>\n</ul>\n</li>\n<li>\n<p>스크롤 이벤트가 발생하면 컴포지터 스레드는 GPU로 보낼 다른 합성 프레임을 만든다.(레이어는 이미 래스터화되어 있으므로 새 프레임을 합성하기만 하면 된다. 애니메이션도 동일)</p>\n</li>\n<li>\n<p>레이아웃이나 페인트를 다시 계산해야 할 경우에는 메인 스레드가 관여해야 하지만 합성은 메인 스레드와 별개로 작동할 수 있어 자바스크립트 실행이나 스타일 계산을 기다리지 않아도 되기 때문에 성능이 가장 부드럽다.</p>\n</li>\n</ul>\n<h2>컴포지터가 사용자 입력을 받았을 때</h2>\n<ul>\n<li>사용자 제스처가 발생하면 브라우저 프로세스는 이벤트 유형과 이벤트가 발생한 좌표를 렌더러 프로세스로 보낸다.</li>\n<li>렌더러 프로세스는 이벤트 대상을 찾고 해당 대상과 연결된 이벤트 리스너를 실행해 이벤트를 적절하게 처리한다.</li>\n</ul>\n<h3>고속 스크롤 불가 영역</h3>\n<ul>\n<li>\n<p>자바스크립트 실행은 메인 스레드의 작업이므로, 웹 페이지가 합성될 때 컴포지터 스레드는 이벤트 핸들러가 연결된 영역을 ‘고속 스크롤 불가 영역’이라고 표시한다.</p>\n</li>\n<li>\n<p>입력 이벤트가 고속 스크롤 불가 영역 밖에서 발생했다면 컴포지터 스레드는 메인 스레드를 기다리지 않고 새 프레임을 합성한다.</p>\n</li>\n<li>\n<p>하나의 이벤트 핸들러를 최상위 요소에 연결하여 이벤트를 위임할 경우 웹 페이지의 모든 영역이 고속 스크롤 불가 영역으로 표시된다.</p>\n</li>\n<li>\n<p>이때 컴포지터 스레드는 입력 이벤트가 들어올 때마다 메인 스레드와 통신해야 하고 메인 스레드가 일을 끝내기를 기다려야 한다.(부드러운 스크롤링이 어렵다.)</p>\n</li>\n<li>\n<p>여전히 메인 스레드에서 이벤트를 받지만 컴포지터가 메인 스레드의 처리를 기다리지 않고 새 프레임을 만들 수 있도록 이벤트 핸들러에 <code class=\"language-text\">passive: true</code> 옵션을 줄 수 있다.</p>\n</li>\n</ul>\n<h3>메인 스레드로 이벤트를 전송하는 것을 최소화하기</h3>\n<ul>\n<li>메인 스레드 호출이 과도해지는 것을 막기 위해 브라우저는 연속적인 이벤트(mousewheel , mousemove 등)를 합쳐서 바로 다음번 requestAnimationFrame() 메서드 실행 직전까지 전송(dispatch)하지 않고 기다린다.</li>\n<li>keydown, keyup과 같은 비연속적인(discrete) 이벤트는 즉시 전달된다.</li>\n</ul>\n<h2>참조</h2>\n<ul>\n<li><a href=\"https://d2.naver.com/helloworld/5237120\" target=\"_blank\" rel=\"nofollow\">최신 브라우저의 내부 살펴보기 3 - 렌더러 프로세스의 내부 동작</a></li>\n<li><a href=\"https://d2.naver.com/helloworld/6204533\" target=\"_blank\" rel=\"nofollow\">최신 브라우저의 내부 살펴보기 4 - 컴포지터가 사용자 입력을 받았을 때</a></li>\n</ul>","frontmatter":{"title":"브라우저는 어떻게 동작하는가 - 2부","summary":"브라우저 동작 원리에 대한 흐름을 알아본다.","date":"2021.08.13.","categories":["브라우저"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACIElEQVQ4y5WU22sTQRTG+7f55N/ho+Crr774rG9a25jWiggihULVWhVbFcUqDU0iIfaSZHeTXpLubrL3y+xPZnJx0wa0A9+emeHMt+ec78zMAQghLiAb2nQGRM4KQZZlkkJZiTn5ieOYMAwZj7HT/468vyJ0HAfXdWk2WxwdNmi3OzSOGpTLFSrlqrLlvRFG84P9Q+Urz12KcDAYEAQB7zY/sPFmk9qvGp8/fWH+wQIL8wWWHj9hqfiUYnGF5eIKS9IuP+PRwwK1Wp1x2SaE8i+WZeH7PiLLSK+QbhzFk+imCU0LLwhApLD/GyFrmgYkYROI6IaCkmMDCce+4KAfyzyJwog0TRWmCM/Nc0ScUj1pce/+bfCqOOuvKd28AdEhd7dtrq+tARZ3dlyurbZIkgzXcej3+yo7Mv4SmpZF5IfYacyuVVVRpScDvI2vsuQYVsiP+plK88hO2Gn7al/W37ZtPM+bVtk0zckmEcRvt+iXdtVy9fsxm3tdNfc/voJ6ZaisELMJZWEDPyAMQhk1yVkX9/lLwu0t/CDmVqHM4vuWOuC+WMT7+Q0hlU1TBv0ZhEr2UfdPmtUfpiRHkORkjcIplR3HvUw4Ju11z9E1HUM3MNoddN1Q645hoOs6mqaj5/a1lsbp6ZlKeyah5/lYpk2321POkiAPRaJpublOr9dTKo9vzNys+5iN+iuK/g15w2Qg8i2Y9OHFF+Oqj0M+kD+UMnO+3FJUwQAAAABJRU5ErkJggg==","aspectRatio":1.3157894736842106,"src":"/static/62b411c384c028a8fc0968808c356c02/c019b/browser.png","srcSet":"/static/62b411c384c028a8fc0968808c356c02/a9f05/browser.png 200w,\n/static/62b411c384c028a8fc0968808c356c02/23840/browser.png 400w,\n/static/62b411c384c028a8fc0968808c356c02/c019b/browser.png 800w,\n/static/62b411c384c028a8fc0968808c356c02/00376/browser.png 1200w,\n/static/62b411c384c028a8fc0968808c356c02/a9bfd/browser.png 1216w","srcWebp":"/static/62b411c384c028a8fc0968808c356c02/210fa/browser.webp","srcSetWebp":"/static/62b411c384c028a8fc0968808c356c02/8444f/browser.webp 200w,\n/static/62b411c384c028a8fc0968808c356c02/42fc5/browser.webp 400w,\n/static/62b411c384c028a8fc0968808c356c02/210fa/browser.webp 800w,\n/static/62b411c384c028a8fc0968808c356c02/3058d/browser.webp 1200w,\n/static/62b411c384c028a8fc0968808c356c02/38f0d/browser.webp 1216w","sizes":"(max-width: 800px) 100vw, 800px"}},"publicURL":"/static/62b411c384c028a8fc0968808c356c02/browser.png"}}}}]}},"pageContext":{"slug":"/브라우저는_어떻게_동작하는가_2부/"}},"staticQueryHashes":[]}