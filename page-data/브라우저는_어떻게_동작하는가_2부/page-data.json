{"componentChunkName":"component---src-templates-post-template-tsx","path":"/브라우저는_어떻게_동작하는가_2부/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h1>브라우저는 어떻게 동작하는가 - 2부</h1>\n<h2>렌더러 프로세스가 HTML 문서를 받았을 때 어떤 절차를 거쳐 화면을 구성하는가.</h2>\n<h2>렌더러 프로세스</h2>\n<ul>\n<li>메인 스레드</li>\n<li>워커 스레드</li>\n<li>컴포지터 스레드</li>\n<li>래스터 스레드</li>\n</ul>\n<h2>렌더링 파이프라인</h2>\n<p><strong>DOM : 파싱 -> CSSOM : 스타일 계산 -> Render Tree : 레이아웃 -> Paint Tree : 페인트 -> Compositor Frame: 합성</strong></p>\n<h3>파싱</h3>\n<ul>\n<li>문자열 HTML을 해석하여 DOM 객체 트리로 변환한다.</li>\n<li>DOM을 구축하는 동안 프리로드(Preload) 스캐너가 동시에 실행되어 <code class=\"language-text\">&lt;img></code>, <code class=\"language-text\">&lt;link></code>같은 태그가 있으면 브라우저 프로세스의 네트워크 스레드에 요청을 보낸다.</li>\n<li>HTML 파서는 <code class=\"language-text\">&lt;script></code> 태그를 만나면 HTML 문서의 파싱을 일시 중지한 다음 자바스크립트 코드를 로딩하고 파싱해 실행한다.(자바스크립트가 문서의 모양을 변경할 수 있기 때문이다.)</li>\n<li><code class=\"language-text\">&lt;script></code> 태그에 async 속성이나 defer 속성을 추가하면 브라우저가 자바스크립트 코드를 비동기적으로 로딩하고 실행하면서 HTML 파싱을 막지 않는다.</li>\n</ul>\n<h3>스타일 계산</h3>\n<ul>\n<li>메인 스레드는 CSS를 파싱하고 각 DOM 노드에 해당되는 계산된 스타일(computed style)을 확정한다.(개발자 도구의 computed 패널에서 확인이 가능하다.)</li>\n</ul>\n<h3>레이아웃</h3>\n<ul>\n<li>메인 스레드는 DOM과 CSSOM을 훑어가며 렌더 트리를 만든다.</li>\n<li>렌더 트리는 위치, 크기, 모양 같은 정보를 가지고 있고, 해당 페이지에 보이는 요소에 관련된 정보만 가지고 있다.</li>\n<li>렌더 트리를 순회하면서 속성 트리를 별도로 만든다.(노드마다 속성 정보를 가지고 있는 것이 아니라 속성 트리에서 속성은 별도로 관리하고, 각 노드는 속성 트리의 노드를 참조한다.)</li>\n</ul>\n<h3>페인트</h3>\n<ul>\n<li>메인 스레드는 페인트 기록(paint record)을 생성하기 위해 렌더 트리를 순회하면서 <strong>어떤 순서로 그려야 할지</strong>를 판단하여 기록한다.</li>\n</ul>\n<h3>합성</h3>\n<ul>\n<li>웹 페이지의 각 부분을 레이어로 분리해 별도로 래스터화(rasterizing, 정보를 화면의 픽셀로 변환하는 작업)한다.\n<ul>\n<li>메인 스레드가 어떤 요소가 어떤 레이어에 있어야 하는지 확인하기 위해 렌더 트리를 순회하면서 레이어 트리를 만든다.(개발자 도구의 Performance 패널에서 Update Layer Tree라고 되어 있다.)</li>\n<li>컴포지터 스레드는 레이어를 타일(tile) 형태로 나눠 각 타일을 래스터 스레드로 보낸다.</li>\n<li>래스터 스레드는 각 타일을 래스터화해 GPU 메모리에 저장한다.</li>\n</ul>\n</li>\n<li>컴포지터 스레드에서 타일을 움직여 웹페이지로 합성한다.(합성 프레임, 스크롤 되었을 때 레이어는 이미 래스터화되어 있으므로 새 프레임을 합성하기만 하면 된다. 애니메이션도 동일)</li>\n</ul>\n<h2>컴포지터가 사용자 입력을 받았을 때</h2>\n<ul>\n<li>사용자 제스처가 발생하면 브라우저 프로세스는 이벤트 유형과 이벤트가 발생한 좌표를 렌더러 프로세스로 보낸다.</li>\n<li>렌더러 프로세스는 이벤트 대상을 찾고 해당 대상과 연결된 이벤트 리스너를 실행해 이벤트를 적절하게 처리한다.</li>\n</ul>\n<h3>고속 스크롤 불가 영역</h3>\n<ul>\n<li>\n<p>자바스크립트 실행은 메인 스레드의 작업이므로, 웹 페이지가 합성될 때 컴포지터 스레드는 이벤트 핸들러가 연결된 영역을 ‘고속 스크롤 불가 영역’이라고 표시한다.</p>\n</li>\n<li>\n<p>입력 이벤트가 고속 스크롤 불가 영역 밖에서 발생했다면 컴포지터 스레드는 메인 스레드를 기다리지 않고 새 프레임을 합성한다.</p>\n</li>\n<li>\n<p>하나의 이벤트 핸들러를 최상위 요소에 연결하여 이벤트를 위임할 경우 웹 페이지의 모든 영역이 고속 스크롤 불가 영역으로 표시된다.</p>\n</li>\n<li>\n<p>이때 컴포지터 스레드는 입력 이벤트가 들어올 때마다 메인 스레드와 통신해야 하고 메인 스레드가 일을 끝내기를 기다려야 한다.(부드러운 스크롤링이 어렵다.)</p>\n</li>\n<li>\n<p>여전히 메인 스레드에서 이벤트를 받지만 컴포지터가 메인 스레드의 처리를 기다리지 않고 새 프레임을 만들 수 있도록 이벤트 핸들러에 <code class=\"language-text\">passive: true</code> 옵션을 줄 수 있다.</p>\n</li>\n</ul>\n<h3>메인 스레드로 이벤트를 전송하는 것을 최소화하기</h3>\n<ul>\n<li>메인 스레드 호출이 과도해지는 것을 막기 위해 브라우저는 연속적인 이벤트(mousewheel , mousemove 등)를 합쳐서 바로 다음번 requestAnimationFrame() 메서드 실행 직전까지 전송(dispatch)하지 않고 기다린다.</li>\n<li>keydown, keyup과 같은 비연속적인(discrete) 이벤트는 즉시 전달된다.</li>\n</ul>\n<h2>참조</h2>\n<ul>\n<li><a href=\"https://d2.naver.com/helloworld/5237120\" target=\"_blank\" rel=\"nofollow\">최신 브라우저의 내부 살펴보기 3 - 렌더러 프로세스의 내부 동작</a></li>\n<li><a href=\"https://d2.naver.com/helloworld/6204533\" target=\"_blank\" rel=\"nofollow\">최신 브라우저의 내부 살펴보기 4 - 컴포지터가 사용자 입력을 받았을 때</a></li>\n</ul>","frontmatter":{"title":"브라우저는 어떻게 동작하는가 - 2부","summary":"브라우저 동작 원리에 대한 흐름을 알아본다.","date":"2021.08.13.","categories":["브라우저"],"thumbnail":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAACIElEQVQ4y5WU22sTQRTG+7f55N/ho+Crr774rG9a25jWiggihULVWhVbFcUqDU0iIfaSZHeTXpLubrL3y+xPZnJx0wa0A9+emeHMt+ec78zMAQghLiAb2nQGRM4KQZZlkkJZiTn5ieOYMAwZj7HT/468vyJ0HAfXdWk2WxwdNmi3OzSOGpTLFSrlqrLlvRFG84P9Q+Urz12KcDAYEAQB7zY/sPFmk9qvGp8/fWH+wQIL8wWWHj9hqfiUYnGF5eIKS9IuP+PRwwK1Wp1x2SaE8i+WZeH7PiLLSK+QbhzFk+imCU0LLwhApLD/GyFrmgYkYROI6IaCkmMDCce+4KAfyzyJwog0TRWmCM/Nc0ScUj1pce/+bfCqOOuvKd28AdEhd7dtrq+tARZ3dlyurbZIkgzXcej3+yo7Mv4SmpZF5IfYacyuVVVRpScDvI2vsuQYVsiP+plK88hO2Gn7al/W37ZtPM+bVtk0zckmEcRvt+iXdtVy9fsxm3tdNfc/voJ6ZaisELMJZWEDPyAMQhk1yVkX9/lLwu0t/CDmVqHM4vuWOuC+WMT7+Q0hlU1TBv0ZhEr2UfdPmtUfpiRHkORkjcIplR3HvUw4Ju11z9E1HUM3MNoddN1Q645hoOs6mqaj5/a1lsbp6ZlKeyah5/lYpk2321POkiAPRaJpublOr9dTKo9vzNys+5iN+iuK/g15w2Qg8i2Y9OHFF+Oqj0M+kD+UMnO+3FJUwQAAAABJRU5ErkJggg==","aspectRatio":1.3157894736842106,"src":"/static/62b411c384c028a8fc0968808c356c02/c019b/browser.png","srcSet":"/static/62b411c384c028a8fc0968808c356c02/a9f05/browser.png 200w,\n/static/62b411c384c028a8fc0968808c356c02/23840/browser.png 400w,\n/static/62b411c384c028a8fc0968808c356c02/c019b/browser.png 800w,\n/static/62b411c384c028a8fc0968808c356c02/00376/browser.png 1200w,\n/static/62b411c384c028a8fc0968808c356c02/a9bfd/browser.png 1216w","srcWebp":"/static/62b411c384c028a8fc0968808c356c02/210fa/browser.webp","srcSetWebp":"/static/62b411c384c028a8fc0968808c356c02/8444f/browser.webp 200w,\n/static/62b411c384c028a8fc0968808c356c02/42fc5/browser.webp 400w,\n/static/62b411c384c028a8fc0968808c356c02/210fa/browser.webp 800w,\n/static/62b411c384c028a8fc0968808c356c02/3058d/browser.webp 1200w,\n/static/62b411c384c028a8fc0968808c356c02/38f0d/browser.webp 1216w","sizes":"(max-width: 800px) 100vw, 800px"}},"publicURL":"/static/62b411c384c028a8fc0968808c356c02/browser.png"}}}}]}},"pageContext":{"slug":"/브라우저는_어떻게_동작하는가_2부/"}},"staticQueryHashes":[]}